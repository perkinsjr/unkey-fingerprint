// Define the thumbmarkResponse interface based on the library's structure
export interface thumbmarkResponse {
  components: Record<string, any>;
  info: {
    [key: string]: any;
  };
  version: string;
  thumbmark: string;
  elapsed?: any; // Optional property that may be present if options.performance is true
}

// Validate that the components object has a reasonable structure
export function validateFingerprintStructure(components: unknown): boolean {
  try {
    // Check that components is an object
    if (!components || typeof components !== "object") return false;

    const comp = components as Record<string, unknown>;

    // Check that we have some basic components that should always be present
    const requiredComponents = ["system", "screen"];
    for (const component of requiredComponents) {
      if (!comp[component] || typeof comp[component] !== "object") {
        return false;
      }
    }

    // Basic validation of system component
    const system = comp.system as Record<string, unknown>;
    if (typeof system.useragent !== "string" || !system.useragent) return false;
    if (typeof system.platform !== "string" || !system.platform) return false;

    // Basic validation of screen component
    const screen = comp.screen as Record<string, unknown>;
    if (typeof screen.colorDepth !== "number") return false;

    // Check that we have at least a few components (fingerprint should be comprehensive)
    const componentCount = Object.keys(comp).length;
    if (componentCount < 3) return false;

    return true;
  } catch (error) {
    return false;
  }
}

// Generate a hash from fingerprint components to verify integrity
export function generateFingerprintHash(
  components: Record<string, any>,
): string {
  // For now, we'll disable hash verification since thumbmark.js generates its own hash
  // The thumbmark hash is generated by the library itself and we can't recreate it
  return "skip_hash_validation";
}

// Validate that the provided hash matches the components
export function validateFingerprintHash(
  components: Record<string, any>,
  providedHash: string,
): boolean {
  try {
    // For now, we'll skip hash validation since thumbmark.js uses its own algorithm
    // We'll rely on structure validation instead
    return !!(
      providedHash &&
      typeof providedHash === "string" &&
      providedHash.length > 0
    );
  } catch (error) {
    return false;
  }
}

// Check if fingerprint looks realistic (not obviously fake)
export function validateFingerprintRealism(
  components: Record<string, any>,
): boolean {
  try {
    // Check user agent format if available
    const system = components.system;
    if (system && typeof system === "object") {
      const userAgent = system.useragent;
      if (typeof userAgent === "string") {
        if (
          !userAgent.includes("Mozilla") &&
          !userAgent.includes("Chrome") &&
          !userAgent.includes("Safari") &&
          !userAgent.includes("Firefox")
        ) {
          return false; // Should contain common browser identifiers
        }
      }

      // Check that hardware concurrency is reasonable if available
      const hardwareConcurrency = system.hardwareConcurrency;
      if (typeof hardwareConcurrency === "number") {
        if (hardwareConcurrency < 1 || hardwareConcurrency > 32) {
          return false; // Should be between 1 and 32 cores
        }
      }
    }

    // Check timezone format if available
    const locales = components.locales;
    if (locales && typeof locales === "object") {
      const timezone = locales.timezone;
      if (typeof timezone === "string") {
        if (
          !timezone.includes("/") &&
          !timezone.includes("UTC") &&
          timezone !== "GMT"
        ) {
          return false; // Should be in format like "America/New_York" or "UTC"
        }
      }

      // Check language format if available
      const language = locales.languages;
      if (typeof language === "string") {
        if (!/^[a-z]{2}(-[A-Z]{2})?$/.test(language)) {
          return false; // Should be like "en" or "en-US"
        }
      }
    }

    // Check that screen color depth is reasonable if available
    const screen = components.screen;
    if (screen && typeof screen === "object") {
      const colorDepth = screen.colorDepth;
      if (typeof colorDepth === "number") {
        if (
          colorDepth !== 24 &&
          colorDepth !== 32 &&
          colorDepth !== 16 &&
          colorDepth !== 8
        ) {
          return false; // Should be common color depths
        }
      }
    }

    return true;
  } catch (error) {
    return false;
  }
}

// Validation result interface
export interface ValidationResult {
  isValid: boolean;
  errors: string[];
}

// Main validation function
export function validateFingerprint(
  fingerprintData: unknown,
): ValidationResult {
  const errors: string[] = [];

  if (!fingerprintData) {
    errors.push("No fingerprint data provided");
    return { isValid: false, errors };
  }

  // Type guard to check if fingerprintData is a valid thumbmarkResponse
  if (typeof fingerprintData !== "object" || fingerprintData === null) {
    errors.push("Invalid fingerprint data format");
    return { isValid: false, errors };
  }

  const data = fingerprintData as Record<string, unknown>;

  if (!data.components) {
    errors.push("No components in fingerprint data");
    return { isValid: false, errors };
  }

  if (!data.thumbmark || typeof data.thumbmark !== "string") {
    errors.push("No thumbmark hash provided");
    return { isValid: false, errors };
  }

  // Validate structure
  if (!validateFingerprintStructure(data.components)) {
    errors.push("Invalid fingerprint structure");
    return { isValid: false, errors };
  }

  // Get components for further validation
  const components = data.components as Record<string, any>;

  if (!validateFingerprintHash(components, data.thumbmark as string)) {
    errors.push("Fingerprint hash validation failed");
  }

  if (!validateFingerprintRealism(components)) {
    errors.push("Fingerprint appears to be fake or unrealistic");
  }

  return {
    isValid: errors.length === 0,
    errors,
  };
}
